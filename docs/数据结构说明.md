# 稳定性保持系统 数据结构说明

## 1. 概述

本文档详细描述了稳定性保持系统中使用的核心数据结构和PLC地址映射关系。这些数据结构是系统内部处理逻辑和外部接口交互的基础。

稳定性保持系统主要通过Modbus TCP协议与PLC设备进行通信，读取和写入特定地址的数据。系统内部使用结构化的数据模型来表示这些状态信息，并通过API接口提供给上层应用。

### 1.1 开发环境

- **操作系统**：Windows 11
- **开发IDE**：Visual Studio 2022
- **构建工具**：Make
- **版本控制**：Git

### 1.2 运行环境

- **操作系统**：Ubuntu Server 24.04
- **编译器**：GCC 11+
- **构建工具**：Make
- **包管理器**：vcpkg

### 1.3 依赖库

- **HTTP服务**：Microsoft C++ REST SDK (cpprestsdk) 2.10.19
- **PLC通信**：libmodbus 3.1.10
- **JSON处理**：nlohmann/json 3.11.3
- **日志系统**：spdlog 1.9.2
- **格式化库**：fmt 9.1.0

### 1.4 数据流

系统数据流如下：

```
+------------------+     +------------------+     +------------------+
|    PLC设备       |     |    Modbus通信    |     |    系统内部      |
|                  | <-> |    libmodbus     | <-> |    数据结构     |
|                  |     |    3.1.10        |     |    DeviceState  |
+------------------+     +------------------+     +------------------+
                              ↑
                              |
                    +------------------+
                    |    REST API      |
                    |   cpprestsdk     |
                    |    2.10.19       |
                    +------------------+
                              ↑
                              |
                    +------------------+
                    |    上层应用      |
                    |                  |
                    +------------------+
```

## 2. 数据类型定义

### 2.1 基本数据类型

在系统内部，我们使用以下类型来表示PLC数据：

```cpp
// 8位字节类型，用于VB地址
using VB = uint8_t;  

// 16位字类型，用于VW地址
using VW = int16_t;  
```

这些类型映射到PLC设备中对应的数据类型，确保数据格式的一致性。

### 2.2 PLC地址定义

系统中的所有PLC地址通过`plc_address`命名空间进行管理：

```cpp
namespace plc_address {
    // VB 地址（字节类型，8位）
    const uint16_t VB_OPERATION_MODE = 1000;  // 自动按钮（操作）: 1=手动, 2=自动
    const uint16_t VB_EMERGENCY_STOP = 1001;  // 急停按钮: 1=复位, 2=急停
    const uint16_t VB_OIL_PUMP = 1002;        // 油泵状态: 1=停止, 2=启动
    const uint16_t VB_CYLINDER_STATE = 1003;  // 刚柔缸状态: 1=下降停止, 2=下降加压, 4=上升停止, 8=上升停止
    const uint16_t VB_LIFT_PLATFORM1 = 1004;  // 升降平台1状态: 1=上升, 2=上升停止, 4=下降, 8=下降停止
    const uint16_t VB_LIFT_PLATFORM2 = 1005;  // 升降平台2状态: 1=上升, 2=上升停止, 4=下降, 8=下降停止
    const uint16_t VB_HEATER = 1006;          // 电加热状态: 1=停止, 2=启动
    const uint16_t VB_AIR_COOLING = 1007;     // 风冷状态: 1=停止, 2=启动
    const uint16_t VB_ALARM = 1008;           // 报警信号: 0=油温低, 1=油温高, 2=液位低, 4=液位高, 8=滤芯堵
    const uint16_t VB_LEVELING = 1009;        // 电动缸调平: 1=停止, 2=启动
    
    // VW 地址（字类型，16位）
    const uint16_t VW_CYLINDER_PRESSURE = 100;  // 刚柔缸压力
    const uint16_t VW_PLATFORM1_PRESSURE = 104; // 升降平台1上升停止压力值
    const uint16_t VW_PLATFORM2_PRESSURE = 108; // 升降平台2上升停止压力值
    const uint16_t VW_TILT_ANGLE = 112;        // 平台倾斜角度
    const uint16_t VW_POSITION = 116;          // 平台位置信息
}
```

## 3. 核心数据结构

### 3.1 设备状态结构 (DeviceState)

`DeviceState`结构是系统的核心数据结构，用于存储和管理设备的当前状态信息：

```cpp
struct DeviceState {
    // 原始数据存储
    struct RawData {
        uint8_t vb_data[2000] = {0};   // VB地址范围
        int16_t vw_data[200] = {0};    // VW地址范围
    } raw;
    
    // 解析后的状态信息
    std::string operationMode;     // 操作模式："手动"/"自动"
    std::string emergencyStop;     // 急停状态："复位"/"急停"
    std::string oilPumpStatus;     // 油泵状态："停止"/"启动"
    std::string cylinderState;     // 刚柔缸状态："下降停止"/"下降加压"/"上升停止"/"上升"
    std::string platform1State;    // 升降平台1状态："上升"/"上升停止"/"下降"/"下降停止"
    std::string platform2State;    // 升降平台2状态："上升"/"上升停止"/"下降"/"下降停止"
    std::string heaterStatus;      // 电加热状态："停止"/"启动"
    std::string coolingStatus;     // 风冷状态："停止"/"启动"
    std::string alarmStatus;       // 报警状态信息："油温低"/"油温高"/"液位低"/"液位高"/"滤芯堵"
    std::string levelingStatus;    // 电动缸调平："停止"/"启动"
    
    // 解析后的数值指标
    double cylinderPressure;       // 刚柔缸压力值
    double platform1Pressure;      // 升降平台1上升停止压力值
    double platform2Pressure;      // 升降平台2上升停止压力值
    double tiltAngle;              // 平台倾斜角度
    int platformPosition;          // 平台位置信息
    
    // 便捷访问方法
    inline uint8_t getVB(uint16_t address) const {
        return raw.vb_data[address];
    }
    
    inline int16_t getVW(uint16_t address) const {
        return raw.vw_data[address];
    }
    
    inline void setVB(uint16_t address, uint8_t value) {
        raw.vb_data[address] = value;
    }
    
    inline void setVW(uint16_t address, int16_t value) {
        raw.vw_data[address] = value;
    }
    
    inline bool isBitSet(uint16_t address, uint8_t bit_position) const {
        return (raw.vb_data[address] & (1 << bit_position)) != 0;
    }
    
    inline void setBit(uint16_t address, uint8_t bit_position, bool value) {
        if (value) {
            raw.vb_data[address] |= (1 << bit_position);
        } else {
            raw.vb_data[address] &= ~(1 << bit_position);
        }
    }
};
```

该结构有以下特点：

1. **原始数据与解析数据分离**：使用嵌套的`RawData`结构存储从PLC读取的原始数据，而外部使用解析后的人类可读形式
2. **便捷访问方法**：提供了获取/设置特定地址数据的方法，简化了PLC数据的访问
3. **位级操作**：支持对单个位的读取和设置，适用于处理状态位

### 3.2 异步任务结构 (AsyncTask)

`AsyncTask`结构用于表示异步操作任务：

```cpp
struct AsyncTask {
    int taskId;            // 任务ID
    int defectId;          // 缺陷ID
    std::string operation; // 操作类型，如"rigid"、"flexible"、"up"、"down"等
    std::string target;    // 操作目标，如平台编号
};
```

## 4. PLC地址映射详解

### 4.1 VB地址（8位字节）

| 地址 | 变量名 | 数据说明 | 取值与含义 |
|------|--------|----------|------------|
| 1000 | VB_OPERATION_MODE | 操作模式 | 1=手动, 2=自动 |
| 1001 | VB_EMERGENCY_STOP | 急停按钮 | 1=复位, 2=急停 |
| 1002 | VB_OIL_PUMP | 油泵状态 | 1=停止, 2=启动 |
| 1003 | VB_CYLINDER_STATE | 刚柔缸状态 | 1=下降停止, 2=下降加压, 4=上升停止, 8=上升 |
| 1004 | VB_LIFT_PLATFORM1 | 升降平台1状态 | 1=上升, 2=上升停止, 4=下降, 8=下降停止 |
| 1005 | VB_LIFT_PLATFORM2 | 升降平台2状态 | 1=上升, 2=上升停止, 4=下降, 8=下降停止 |
| 1006 | VB_HEATER | 电加热状态 | 1=停止, 2=启动 |
| 1007 | VB_AIR_COOLING | 风冷状态 | 1=停止, 2=启动 |
| 1008 | VB_ALARM | 报警信号 | 位0=油温低, 位1=油温高, 位2=液位低, 位3=液位高, 位4=滤芯堵 |
| 1009 | VB_LEVELING | 电动缸调平 | 1=停止, 2=启动 |

### 4.2 VW地址（16位字）

| 地址 | 变量名 | 数据说明 | 取值与转换 |
|------|--------|----------|------------|
| 100 | VW_CYLINDER_PRESSURE | 刚柔缸压力 | 原始值/100=MPa |
| 104 | VW_PLATFORM1_PRESSURE | 升降平台1压力 | 原始值/100=MPa |
| 108 | VW_PLATFORM2_PRESSURE | 升降平台2压力 | 原始值/100=MPa |
| 112 | VW_TILT_ANGLE | 平台倾斜角度 | 原始值/100=度 |
| 116 | VW_POSITION | 平台位置信息 | 单位：mm |

## 5. 数据转换逻辑

### 5.1 原始数据解析

系统在从PLC读取原始数据后，需要通过解析转换为可读状态：

```cpp
void PLCManager::parse_raw_values() {
    std::lock_guard<std::mutex> lock(m_mutex);
    
    // 解析操作模式
    uint8_t mode = m_current_state.getVB(plc_address::VB_OPERATION_MODE);
    if (mode == 1) {
        m_current_state.operationMode = "手动";
    } else if (mode == 2) {
        m_current_state.operationMode = "自动";
    } else {
        m_current_state.operationMode = "未知";
    }
    
    // 解析急停状态
    uint8_t emergency = m_current_state.getVB(plc_address::VB_EMERGENCY_STOP);
    if (emergency == 1) {
        m_current_state.emergencyStop = "复位";
    } else if (emergency == 2) {
        m_current_state.emergencyStop = "急停";
    } else {
        m_current_state.emergencyStop = "未知";
    }
    
    // 解析油泵状态
    uint8_t pump = m_current_state.getVB(plc_address::VB_OIL_PUMP);
    if (pump == 1) {
        m_current_state.oilPumpStatus = "停止";
    } else if (pump == 2) {
        m_current_state.oilPumpStatus = "启动";
    } else {
        m_current_state.oilPumpStatus = "未知";
    }
    
    // 解析刚柔缸状态
    uint8_t cylinder = m_current_state.getVB(plc_address::VB_CYLINDER_STATE);
    if (cylinder & 0x01) {
        m_current_state.cylinderState = "下降停止";
    } else if (cylinder & 0x02) {
        m_current_state.cylinderState = "下降加压";
    } else if (cylinder & 0x04) {
        m_current_state.cylinderState = "上升停止";
    } else if (cylinder & 0x08) {
        m_current_state.cylinderState = "上升";
    } else {
        m_current_state.cylinderState = "未知";
    }
    
    // 解析升降平台1状态
    uint8_t platform1 = m_current_state.getVB(plc_address::VB_LIFT_PLATFORM1);
    if (platform1 & 0x01) {
        m_current_state.platform1State = "上升";
    } else if (platform1 & 0x02) {
        m_current_state.platform1State = "上升停止";
    } else if (platform1 & 0x04) {
        m_current_state.platform1State = "下降";
    } else if (platform1 & 0x08) {
        m_current_state.platform1State = "下降停止";
    } else {
        m_current_state.platform1State = "停止";
    }
    
    // 解析升降平台2状态
    uint8_t platform2 = m_current_state.getVB(plc_address::VB_LIFT_PLATFORM2);
    if (platform2 & 0x01) {
        m_current_state.platform2State = "上升";
    } else if (platform2 & 0x02) {
        m_current_state.platform2State = "上升停止";
    } else if (platform2 & 0x04) {
        m_current_state.platform2State = "下降";
    } else if (platform2 & 0x08) {
        m_current_state.platform2State = "下降停止";
    } else {
        m_current_state.platform2State = "停止";
    }
    
    // 解析电加热状态
    uint8_t heater = m_current_state.getVB(plc_address::VB_HEATER);
    if (heater == 1) {
        m_current_state.heaterStatus = "停止";
    } else if (heater == 2) {
        m_current_state.heaterStatus = "启动";
    } else {
        m_current_state.heaterStatus = "未知";
    }
    
    // 解析风冷状态
    uint8_t cooling = m_current_state.getVB(plc_address::VB_AIR_COOLING);
    if (cooling == 1) {
        m_current_state.coolingStatus = "停止";
    } else if (cooling == 2) {
        m_current_state.coolingStatus = "启动";
    } else {
        m_current_state.coolingStatus = "未知";
    }
    
    // 解析报警状态
    uint8_t alarm = m_current_state.getVB(plc_address::VB_ALARM);
    if (alarm & 0x01) {
        m_current_state.alarmStatus = "油温低";
    } else if (alarm & 0x02) {
        m_current_state.alarmStatus = "油温高";
    } else if (alarm & 0x04) {
        m_current_state.alarmStatus = "液位低";
    } else if (alarm & 0x08) {
        m_current_state.alarmStatus = "液位高";
    } else if (alarm & 0x10) {
        m_current_state.alarmStatus = "滤芯堵";
    } else {
        m_current_state.alarmStatus = "正常";
    }
    
    // 解析电动缸调平状态
    uint8_t leveling = m_current_state.getVB(plc_address::VB_LEVELING);
    if (leveling == 1) {
        m_current_state.levelingStatus = "停止";
    } else if (leveling == 2) {
        m_current_state.levelingStatus = "启动";
    } else {
        m_current_state.levelingStatus = "未知";
    }
    
    // 解析数值指标
    m_current_state.cylinderPressure = m_current_state.getVW(plc_address::VW_CYLINDER_PRESSURE) / 100.0;
    m_current_state.platform1Pressure = m_current_state.getVW(plc_address::VW_PLATFORM1_PRESSURE) / 100.0;
    m_current_state.platform2Pressure = m_current_state.getVW(plc_address::VW_PLATFORM2_PRESSURE) / 100.0;
    m_current_state.tiltAngle = m_current_state.getVW(plc_address::VW_TILT_ANGLE) / 100.0;
    m_current_state.platformPosition = m_current_state.getVW(plc_address::VW_POSITION);
}
```

### 5.2 JSON数据转换

设备状态结构需要转换为JSON格式，以便通过API接口返回：

```cpp
std::string device_state_to_json(const DeviceState& state) {
    // 构建JSON响应
    json response;
    
    // 基本响应信息
    response["msg"] = constants::MSG_SUCCESS;
    
    // 主要状态信息 - 保留接口文档中的liftState和liftPressure向后兼容
    response["liftState"] = state.platform1State;  // 对应图中升降平台状态
    response["liftPressure"] = state.platform1Pressure; // 对应图中升降平台压力值
    
    // 完整状态信息
    response["operationMode"] = state.operationMode;     // 自动按钮状态
    response["emergencyStop"] = state.emergencyStop;     // 急停按钮状态
    response["oilPumpStatus"] = state.oilPumpStatus;     // 油泵状态
    response["cylinderState"] = state.cylinderState;     // 刚柔缸状态
    response["platform1State"] = state.platform1State;   // 升降平台1状态
    response["platform2State"] = state.platform2State;   // 升降平台2状态
    response["heaterStatus"] = state.heaterStatus;       // 电加热状态
    response["coolingStatus"] = state.coolingStatus;     // 风冷状态
    response["alarmStatus"] = state.alarmStatus;         // 报警状态
    response["levelingStatus"] = state.levelingStatus;   // 电动缸调平状态
    
    // 数值指标
    response["cylinderPressure"] = state.cylinderPressure;       // 刚柔缸压力值
    response["platform1Pressure"] = state.platform1Pressure;     // 升降平台1压力值
    response["platform2Pressure"] = state.platform2Pressure;     // 升降平台2压力值
    response["tiltAngle"] = state.tiltAngle;                     // 平台倾斜角度
    response["platformPosition"] = state.platformPosition;       // 平台位置信息
    
    // 添加原始数据（用于调试）
    json raw_data;
    
    // 仅添加有实际使用的地址区域
    const uint16_t used_vb_addresses[] = {
        plc_address::VB_OPERATION_MODE,
        plc_address::VB_EMERGENCY_STOP,
        plc_address::VB_OIL_PUMP,
        plc_address::VB_CYLINDER_STATE,
        plc_address::VB_LIFT_PLATFORM1,
        plc_address::VB_LIFT_PLATFORM2,
        plc_address::VB_HEATER,
        plc_address::VB_AIR_COOLING,
        plc_address::VB_ALARM,
        plc_address::VB_LEVELING
    };
    
    const uint16_t used_vw_addresses[] = {
        plc_address::VW_CYLINDER_PRESSURE,
        plc_address::VW_PLATFORM1_PRESSURE,
        plc_address::VW_PLATFORM2_PRESSURE,
        plc_address::VW_TILT_ANGLE,
        plc_address::VW_POSITION
    };
    
    // 添加VB原始值
    for (const auto& addr : used_vb_addresses) {
        raw_data["vb_" + std::to_string(addr)] = static_cast<int>(state.getVB(addr));
    }
    
    // 添加VW原始值
    for (const auto& addr : used_vw_addresses) {
        raw_data["vw_" + std::to_string(addr)] = state.getVW(addr);
    }
    
    response["raw_data"] = raw_data;
    
    // 设置时间戳
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()).count();
    response["timestamp"] = timestamp;
    
    return response.dump();
}
```

## 6. 操作映射关系

系统将API接口中的操作映射到内部PLC命令：

### 6.1 支撑控制操作映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "rigid" | "刚性支撑" | 启动刚性支撑操作 |
| "flexible" | "柔性复位" | 执行柔性复位操作 |

### 6.2 平台高度控制操作映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "up" | "平台{target}上升" | 启动指定平台上升 |
| "down" | "平台{target}下降" | 启动指定平台下降 |

### 6.3 平台调平控制操作映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "level" | "调平启动" | 启动平台自动调平 |
| "level_reset" | "调平停止" | 停止平台调平 |

### 6.4 电源控制操作映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "on" | "电源开" | 开启电源 |
| "off" | "电源关" | 关闭电源 |

### 6.5 电机控制操作映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "start" | "启动电机" | 启动电机 |
| "stop" | "停止电机" | 停止电机 |

### 6.6 操作模式控制映射

| API操作 | 内部命令 | 执行动作 |
|---------|----------|----------|
| "auto" | "自动模式" | 切换到自动模式 |
| "manual" | "手动模式" | 切换到手动模式 |

## 7. 操作特殊说明

### 7.1 刚柔支撑控制

刚性支撑和柔性复位是互斥操作，执行流程如下：

1. 刚性支撑：
   - 控制刚柔缸下降加压
   - 等待压力达到设定值
   - 完成刚性支撑操作

2. 柔性复位：
   - 控制刚柔缸上升
   - 等待位置复位到初始位置
   - 完成柔性复位操作

### 7.2 平台升降控制

平台升降控制包括两个独立的平台，可以分别控制：

1. 平台上升：
   - 启动指定平台的上升操作
   - 监控压力值，达到设定压力自动停止
   - 完成上升操作

2. 平台下降：
   - 启动指定平台的下降操作
   - 监控位置信息，到达底部位置自动停止
   - 完成下降操作

### 7.3 平台调平控制

平台调平控制使用电动缸实现：

1. 调平启动：
   - 读取倾角传感器数据
   - 控制电动缸调整平台水平度
   - 达到水平状态后完成调平

2. 调平停止：
   - 立即停止调平操作
   - 记录当前状态

## 8. 数据安全性考虑

### 8.1 数据边界检查

为了确保系统安全，所有数据访问都需要进行边界检查：

```cpp
// 安全的VB数据访问
uint8_t safeGetVB(const DeviceState& state, uint16_t address) {
    if (address >= 0 && address < 2000) {
        return state.getVB(address);
    }
    // 越界访问处理
    SPDLOG_ERROR("越界访问VB地址: {}", address);
    return 0;
}

// 安全的VW数据访问
int16_t safeGetVW(const DeviceState& state, uint16_t address) {
    if (address >= 0 && address < 200) {
        return state.getVW(address);
    }
    // 越界访问处理
    SPDLOG_ERROR("越界访问VW地址: {}", address);
    return 0;
}
```

### 8.2 数据有效性验证

PLC读取的数据需要进行有效性验证：

```cpp
bool isValidPressure(double pressure) {
    // 压力值有效范围：0-20 MPa
    return pressure >= 0.0 && pressure <= 20.0;
}

bool isValidAngle(double angle) {
    // 倾角有效范围：-5度到+5度
    return angle >= -5.0 && angle <= 5.0;
}
```

## 9. 性能优化

### 9.1 数据批量读取

为了提高性能，系统采用批量读取策略：

```cpp
// 批量读取VB地址区域
bool readVBRange(modbus_t* ctx, uint16_t start_address, uint16_t count, uint8_t* buffer) {
    if (modbus_read_registers(ctx, start_address, count, (uint16_t*)buffer) == -1) {
        SPDLOG_ERROR("批量读取VB地址失败: {}", modbus_strerror(errno));
        return false;
    }
    return true;
}

// 批量读取VW地址区域
bool readVWRange(modbus_t* ctx, uint16_t start_address, uint16_t count, int16_t* buffer) {
    if (modbus_read_registers(ctx, start_address, count, (uint16_t*)buffer) == -1) {
        SPDLOG_ERROR("批量读取VW地址失败: {}", modbus_strerror(errno));
        return false;
    }
    return true;
}
```

### 9.2 数据缓存策略

为了减少PLC通信，系统实现了数据缓存策略：

```cpp
// 上次读取时间
std::chrono::steady_clock::time_point last_read_time;

// 缓存失效时间（毫秒）
constexpr int CACHE_EXPIRY_MS = 100;

// 检查缓存是否有效
bool isCacheValid() {
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
        now - last_read_time).count();
    return elapsed < CACHE_EXPIRY_MS;
}

// 获取设备状态（带缓存）
DeviceState get_current_state_cached() {
    if (!isCacheValid()) {
        // 缓存失效，重新读取
        read_plc_data();
        last_read_time = std::chrono::steady_clock::now();
    }
    return m_current_state;
}
```

## 10. 数据结构使用示例

### 10.1 读取设备状态

```cpp
// 获取当前设备状态
DeviceState state = PLCManager::instance().get_current_state();

// 访问解析后的状态信息
std::cout << "操作模式: " << state.operationMode << std::endl;
std::cout << "急停状态: " << state.emergencyStop << std::endl;
std::cout << "平台1状态: " << state.platform1State << std::endl;
std::cout << "平台1压力: " << state.platform1Pressure << " MPa" << std::endl;

// 访问原始数据
uint8_t raw_mode = state.getVB(plc_address::VB_OPERATION_MODE);
int16_t raw_pressure = state.getVW(plc_address::VW_PLATFORM1_PRESSURE);
```

### 10.2 创建异步任务

```cpp
// 创建刚性支撑任务
TaskManager::instance().create_task(
    12345,  // taskId
    67890,  // defectId
    "rigid" // 操作名称
);

// 创建平台上升任务
TaskManager::instance().create_task(
    12346,  // taskId
    67891,  // defectId
    "up",   // 操作名称
    "1"     // 目标平台
);
``` 